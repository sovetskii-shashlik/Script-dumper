local Players = game:GetService("Players")
local Player = Players.LocalPlayer
print("Started")
local Settings_NoCrash = false

local isfile, writefile = isfile or function(...)end, writefile or function(...)end

local spawn, wait, tostring, tonumber = task.spawn, task.wait, tostring, tonumber

local tinsert, tfind, tremove = table.insert, table.find, table.remove
local format, sub, rep, match = string.format, string.sub, string.rep, string.match
local floor = math.floor

local Instance_new = Instance.new

local JSON = isfile('robloxproperties.json') and readfile('robloxproperties.json') or game:HttpGet("https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/refs/heads/roblox/Mini-API-Dump.json")
if not isfile("robloxproperties.json") then spawn(writefile, "robloxproperties.json", JSON) end

JSON = game:GetService("HttpService"):JSONDecode(JSON)

local Properties = {
    GuiObject = {
        "Position", "Size", "AnchorPoint", "AutomaticSize"
    },
    UIListLayout = {
        "Padding", "SortOrder", "HorizontalAlignment", "FillDirection", "VerticalAlignment"
    },
    UISizeConstraint = {
        "MaxSize"
    },
    UIAspectRatioConstraint = {
        "AspectRatio", "AspectType", "DominantAxis"
    },
    UICorner = {
        "CornerRadius"
    },
    UIStroke = {
        "ApplyStrokeMode", "Color", "Enabled", "LineJoinMode", "Thickness", "Transparency"
    },
    LocalScript = {
        "Source", "Enabled"
    },
    ModuleScript = {
        "Source"
    },
    Script = {
        "Source", "Disabled"
    }
};
local Clone = {
    Frame = "GuiObject",
    TextLabel = "GuiObject",
    TextButton = "GuiObject",
    TextBox = "GuiObject",
    ImageLabel = "GuiObject",
    ImageButton = "GuiObject",
    ScrollingFrame = "GuiObject"
}

for _, Class in next, JSON.Classes do
    if Class.MemoryCategory == "Gui" or Class.MemoryCategory == "Script" then
        local ClassName = Class.Name
        Properties[ClassName] = Properties[ClassName] or Properties[Clone[ClassName]] or {};

        for _, Property in next, Class.Members do
            local Tags = Property.Tags or {}
            if Property.MemberType == "Property" and not tfind(Tags, "ReadOnly") and not tfind(Tags, "Deprecated") and not tfind(Tags, "Hidden") and not tfind(Properties[ClassName], Property.Name) then
                tinsert(Properties[ClassName], Property.Name)
            end
        end
    end
end

local IdentifiersArray = {}
local Identifiers = {};

local function IdentifiersGet(Instance)
    local Identifier = Identifiers[Instance]
    if Identifier then
        return Identifier
    end
    Identifier = Instance.Name
    local dupeCount = 1

    while tfind(IdentifiersArray, Identifier .. (dupeCount == 1 and "" or " " .. dupeCount)) do
        dupeCount += 1
    end

    Identifier = Identifier .. (dupeCount == 1 and "" or " " .. dupeCount)

    tinsert(IdentifiersArray, Identifier)

    Identifiers[Instance] = Identifier
    return Identifier
end

local function FormatDigit(n)
    if n == nil then return "nil" end
    for i = 0, 30 do
        local Number = format(
            "%." .. tostring(i) .. "f",
            n
        )

        if tonumber(Number) == n or i == 30 then
            if tonumber(match(Number, "(%d+)%.")) == 0 then
                Number = sub(Number, 2)
            end
            return Number
        end
    end
end

local function FormatValue(Value)
    if Value == nil then return "nil" end
    local Type = typeof(Value)
    
    if Type == "string" then
        return format("\"%s\"", Value:gsub("\"", "\\\""):gsub("\n", "\\n"))
    elseif Type == "Vector2" then
        return format("Vector2.new(%s, %s)", FormatDigit(Value.X), FormatDigit(Value.Y))
    elseif Type == "UDim2" then
        local X, Y = Value.X, Value.Y
        return format("UDim2.new(%s, %s, %s, %s)", FormatDigit(X.Scale), FormatDigit(X.Offset), FormatDigit(Y.Scale), FormatDigit(Y.Offset))
    elseif Type == "UDim" then
        return format("UDim.new(%s, %s)", FormatDigit(Value.Scale), FormatDigit(Value.Offset))
    elseif Type == "Color3" then
        return format("Color3.fromRGB(%d, %d, %d)", Value.R * 255, Value.G * 255, Value.B * 255)
    elseif Type == "Font" then
        return format("Font.new(%s, %s, %s)", FormatValue(Value.Family), FormatValue(Value.Weight), FormatValue(Value.Style))
    elseif Type == "Instance" then
        if Value == workspace then
            return "workspace"
        elseif Value == game then
            return "game"
        elseif Value == game:GetService("CoreGui") then
            return "game:GetService(\"CoreGui\")"
        end

        local Path = {};
        local P = Value

        while P and P ~= game do
            tinsert(Path, {Instance=P,Index=#Path+1})
            P = P.Parent
        end

        table.sort(Path, function(a, b)
            return a.Index > b.Index
        end)

        local Result = format("game:GetService(%s)", FormatValue(Path[2].Instance.ClassName));
        Path[1] = nil
        Path[2] = nil

        for _, V in next, Path do
            Result = Result .. format(":FindFirstChild(%s)", FormatValue(V.Instance.Name))
        end

        Result = Result:gsub("game:GetService%(\"Players\"):FindFirstChild%(\"" .. Player.Name .. "\"%)", "game:GetService(\"Players\").LocalPlayer")
        Result = Result:gsub("game:GetService(\"Workspace\")", "workspace")

        return Result
    else
        return tostring(Value)
    end
end

local function SafeGet(I, P)
    return pcall(function()
        return I[P]
    end)
end

local function GetScriptSource(Script)
    local Success, Source = pcall(function()
        return Script.Source
    end)
    return Success and Source or "-- Failed to get source"
end

local function StealGui(Gui)
    local start = tick()
    local Table = "a"
    local ScriptsTable = "b"

    local Code = "";
    local bin = format("local %s = {}\nlocal %s = {}\n", Table, ScriptsTable)

    local Defaults = {};

    for _, Instance in next, {Gui, unpack(Gui:GetDescendants())} do
        if Settings_NoCrash then
            wait();
        end
        local Class = Instance.ClassName
        local TargetTable = Instance:IsA("Script") and ScriptsTable or Table
        
        bin = bin .. format("%s[\"%s\"] = Instance.new(\"%s\")\n", TargetTable, IdentifiersGet(Instance), Class)

        if Instance:IsA("Script") then
            local Source = GetScriptSource(Instance)
            Code = Code .. format("%s[\"%s\"].Source = %s\n", TargetTable, IdentifiersGet(Instance), FormatValue(Source))
            
            if Instance:IsA("LocalScript") then
                local Enabled = SafeGet(Instance, "Enabled")
                if Enabled then
                    Code = Code .. format("%s[\"%s\"].Enabled = %s\n", TargetTable, IdentifiersGet(Instance), tostring(Enabled))
                end
            else
                local Disabled = SafeGet(Instance, "Disabled")
                if Disabled then
                    Code = Code .. format("%s[\"%s\"].Disabled = %s\n", TargetTable, IdentifiersGet(Instance), tostring(Disabled))
                end
            end
        else
            for _, Property in next, (Properties[Class] or {}) do
                local Default = Defaults[Class] or Instance_new(Class);

                local Success, Value = SafeGet(Instance, Property)
                local Success2, Value2 = SafeGet(Default, Property)

                if Success and Success2 and Value ~= Value2 then
                    local Formatted = typeof(Value) == "Instance" and format("%s[%s]", Value:IsA("Script") and ScriptsTable or Table, FormatValue(IdentifiersGet(Value))) or FormatValue(Value)

                    Code = Code .. format("%s[\"%s\"][\"%s\"] = %s\n", TargetTable, IdentifiersGet(Instance), Property, Formatted)
                end

                Defaults[Class] = Default
            end
        end

        Code = Code .. format("%s[\"%s\"][\"%s\"] = %s\n", Instance:IsA("Script") and ScriptsTable or Table, IdentifiersGet(Instance), "Name", FormatValue(Instance.Name))
        if _ == 1 then
            Code = Code .. format("%s[\"%s\"][\"%s\"] = %s\n", Table, IdentifiersGet(Instance), "Parent", FormatValue(Gui.Parent))
        else
            local ParentTable = Instance.Parent:IsA("Script") and ScriptsTable or Table
            Code = Code .. format("%s[\"%s\"][\"%s\"] = %s[\"%s\"]\n", TargetTable, IdentifiersGet(Instance), "Parent", ParentTable, IdentifiersGet(Instance.Parent))
        end

        Code = Code .. "\n"
    end

    return bin .. Code, tick() - start
end

return StealGui