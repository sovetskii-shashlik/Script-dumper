-- MOONSEC, LURAPH AND LUAOBFUSCATOR.COM NO WORK
-- Dumper: Intercept user-executed scripts (by Grok, enhanced for VM/Metatable bypass)
-- Dumps deobfuscated source code of user-executed scripts to MihaLogger/ShashlikEx/dump_code/dump.txt

if not writefile or not makefolder or not isfolder then
    error("This dumper requires an exploit with writefile and makefolder support (e.g., Synapse X, Krnl).")
end

if not isfolder("MihaLogger") then
    makefolder("MihaLogger")
end
task.wait()
if not isfolder("MihaLogger/ShashlikEx/dump_code") then
    makefolder("MihaLogger/ShashlikEx/dump_code")
end
task.wait()

local codeFragments = {}

local function logToFile(content)
    local fileName = "MihaLogger/ShashlikEx/dump_code/dump.txt"
    local success, _ = pcall(function()
        writefile(fileName, content)
    end)
    if not success then
        rawset(_G, "dump_backup", content)
    end
end

local function deobfuscate(code)
    local key = 0x5A
    local decrypted = ""
    for i = 1, #code do
        local byte = string.byte(code, i)
        decrypted = decrypted .. string.char(bit32.bxor(byte, key))
    end
    return decrypted
end

local function isObfuscated(code)
    local nonPrintableCount = 0
    for i = 1, #code do
        local byte = string.byte(code, i)
        if byte < 32 or byte > 126 then
            nonPrintableCount = nonPrintableCount + 1
        end
    end
    return nonPrintableCount > (#code / 2)
end

local function processCode(code)
    if type(code) == "string" and code ~= "" then
        if isObfuscated(code) then
            return deobfuscate(code)
        else
            return code
        end
    end
    return nil
end

local function HookFunction(original, hook, method_name)
    local mt = getrawmetatable(original) or {}
    local new_func = function(...)
        hook(...)
        if mt.__call then
            return mt.__call(original, ...)
        end
        return original(...)
    end
    
    if mt.__index or mt.__newindex then
        local success, _ = pcall(setrawmetatable, original, {
            __call = new_func,
            __index = mt.__index,
            __newindex = mt.__newindex
        })
        if not success then
            return new_func
        end
    end
    return new_func
end

local originalLoad = load or function() end -- Заглушка, если load отсутствует
load = HookFunction(originalLoad, function(code, ...)
    local processed = processCode(code)
    if processed then
        table.insert(codeFragments, processed)
    end
end, "load")

local originalLoadstring = loadstring or function() end
loadstring = HookFunction(originalLoadstring, function(code, ...)
    local processed = processCode(code)
    if processed then
        table.insert(codeFragments, processed)
    end
end, "loadstring")

local originalExecute = _G.execute or function() end
local customExecute = HookFunction(originalExecute, function(code)
    local processed = processCode(code)
    if processed then
        table.insert(codeFragments, processed)
    end
    local func, err = loadstring(code)
    if not func then
        error(err)
    end
    return func()
end, "execute")

local function SafeSetGlobal(name, func)
    local success, _ = pcall(function()
        rawset(_G, name, func)
    end)
    if not success and getfenv then
        local env = getfenv()
        rawset(env, name, func)
    end
end

SafeSetGlobal("load", load)
SafeSetGlobal("loadstring", loadstring)
SafeSetGlobal("execute", customExecute)

local function DeepHook(table, key, hook_func)
    local original = rawget(table, key) or function() end
    rawset(table, key, HookFunction(original, hook_func, key))
end

DeepHook(_G, "load", function(code, ...)
    local processed = processCode(code)
    if processed then
        table.insert(codeFragments, processed)
    end
end)
DeepHook(_G, "loadstring", function(code, ...)
    local processed = processCode(code)
    if processed then
        table.insert(codeFragments, processed)
    end
end)

coroutine.wrap(function()
    while true do
        if #codeFragments > 0 then
            local unifiedSource = table.concat(codeFragments, "\n")
            logToFile(unifiedSource)
            codeFragments = {}
        end
        task.wait(5)
    end
end)()